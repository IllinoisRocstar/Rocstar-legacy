/* Generated by Together */

#ifndef NODE_H
#define NODE_H
#include "MVec.hpp"
class Element;
class Face;
class FaceList;
class ElementList;
class Mesh;

class Node {
public:

    enum FlagType{
       e_unset_flag = -1
    };
  
    Node();

    Node(MVec pos);

    Node(MVec pos, int flag);

  // when here node should not be in any face or element
    ~Node();

    void setID(int theID);

    int getID();

    void setPosition(MVec pos);

    MVec getPosition();


    void addFace(Face * face);


    void removeFace(Face * face);

    /**
     * retrieves the number of faces currently associated with this node. 
     */
    int getNumFaces();

    /**
     * Retrieves a pointer to the face referenced by the supplied  index that is associated with this node, i.e., if there are 3 faces associated with this node (use getNumFaces), then index should run from 0 to 2. 
     */
    Face * getFace(int Index);

    /**
     * Retrieves a pointer to the internal array of faces associated with this node.  Use getNumFaces to find out how many are in the array. 
     */
    Face ** getAllFaces();


    void addElement(Element * elem);

    void removeElement(Element * elem);

    /**
     * retrieves the number of elements currently associated with this node. 
     */
    int getNumElements();

    /**
     * Retrieves a pointer to the element referenced by the supplied  index that is associated with this node, i.e., if there are 3 elements associated with this node (use getNumElements), then index should run from 0 to 2. 
     */
    Element * getElement(int Index);

    /**
     * Retrieves a pointer to the internal array of elements associated with this node.  Use getNumElements to find out how many are in the array. 
     */
    Element ** getAllElements();


    Face* sharedFace(Node* n2, Node* n3, Node* n4 = 0 );

    Node* getNext();

    void addNextLink( Node* link );  

    boolean separate( Mesh* mesh, FaceList* list, int new_material );

    int  getFlag() const;
    void  setFlag( int flag );


    friend istream& operator>>(istream& stream, Node& n);

    friend ostream& operator<<(ostream& stream, Node& n);

  
private:    

    ElementList* getSeparateElements( FaceList* list );

    MVec d_position;
    int d_ID;
  
    int d_flag;

    Node * d_nextNode;

    Face * * d_faces;
    int d_faceArraySize;
    int d_numFaces;
  
    Element * * d_elements;
    int d_elementArraySize;
    int d_numElements;
};


inline void Node::setID(int theID)
{ d_ID = theID; }

inline int Node::getID()
{ return d_ID; }

inline void Node::setPosition(MVec pos) 
{ d_position = pos; }

inline MVec Node::getPosition()
{ return d_position; }

inline int Node::getNumFaces()
{ return d_numFaces; }

inline Face * Node::getFace(int Index)
{ return d_faces[Index]; }


inline Face ** Node::getAllFaces()
{ return d_faces; }



inline int Node::getNumElements()
{ return d_numElements; }

inline Element * Node::getElement(int Index)
{ return d_elements[Index]; }


inline Element ** Node::getAllElements()
{ return d_elements; }

inline int  Node::getFlag() const
{return d_flag; }

inline void  Node::setFlag( int flag )
{ d_flag = flag; }

inline ostream & operator<<(ostream & stream, Node & n){
  stream << n.d_ID << '\t' << n.d_position << endl;
  return stream;
}

inline istream & operator>>(istream & stream, Node & n){
  stream >> n.d_ID >> n.d_position;
  return stream;
}

#endif //NODE_H
