/* Generated by Together */

#ifndef MESH_H
#define MESH_H
#include <iostream.h>
#include "general.hpp"

class Element;
class Face;
class Node;
class ElementList;

/**
 * Class Mesh is the main class that holds all information to describe the current
 * state of the mesh.  It has several arrays that are arrays of node, face, 
 * and element objects.  It contains the main work method for the cohesive 
 * insertion algorithm "addCohesive" that will be called from the main program. 
 */
class Mesh {
public:

    Mesh();    
    ~Mesh();
   
    /**
     * The following add/remove/get methods are utility methods to add, remove,
     * or return instances of nodes, faces or elements.  Pointers to the node,
     * face, or element to be added or removed must be provided.
     */
    void addNode(Node* node);
    void addFace(Face* face);
    void addElement(Element* element);
    void removeNode(Node* node);
    void removeFace(Face* face);
    void removeElement(Element* element);

    /**
     * The following get methods return a node, face or element.  To return
     * one of these objects, it's ID must be supplied.  Note: in the input file,
     * all nodes and elements are given IDs by the file author.  However, this
     * code assumes that the nodes and elements are supplied in "ID" order, and
     * it just returns the array element [ID-1].  Thus, if you skip an ID in the
     * input file, and then ask for element ID=50 (assume you skipped 40), you
     * will actually get element 51 back (51 as listed in the input file, but
     * it will be the 50th element that was in the input file).
     */
    Node* getNode(int ID);
    Face* getFace(int ID);
    Element* getElement(int ID);

     /**
     * The following get methods return the number of nodes, faces, or elements
     * currently in the model.  These may not be the same as the sizes of the
     * corresponding arrays in the Mesh class (d_nodes, etc. )
     */
    int getNumNodes();
    int getNumFaces();
    int getNumElements();

     /**
     * The addCohesive method is the driver for the entire process of adding
     * cohesive elements to the mesh.  Currently, it relies on the input of
     * three integers:  material 1 and material 2 are the element material types
     * that should have cohesive elements inserted between them (they can be
     * the same number if it is desired to insert cohesive elements between
     * elements of the same type).  new_material defaults to -1, and is the
     * material type that cohesive elements will be assigned.
     */
    boolean addCohesive( int material1, int material2, int new_material=-1 );

    void  replaceNode( Node* node, Node* new_node, 
		       ElementList *sep_elements, int new_material );

    /**
     * The mesh instream operator is used to drive the reading of the one input
     * file to the code.  This input file contains the node and element
     * definitions for the mesh.  Note that the instream operators for other
     * classes actually do much of the work (i.e., node >> knows how to read a
     * node, element >> knows how to read an element, etc.).
     */
    friend istream & operator>>(istream & stream, Mesh & mesh);

    /**
     * The mesh ostream operator is used to drive the writing of both output
     * fils from the code.  These output files are the augmented node/element
     * file (now containing cohesive elements), and the surface node description
     * file.  Note that the ostream operators for other
     * classes actually do much of the work (i.e., node << knows how to write a
     * node, element << knows how to write an element, etc.).
     */
    friend ostream & operator<<(ostream & stream, Mesh & mesh);

    void  write_boundary(ostream & stream);

private:    
    double calcEdgeLength(int elementID);
    double getMinEdge();
    void setMinEdge(double me);

    /**
     * An ordered array of all nodes in the mesh.  The index of each Node in the
     * array is also stored as the ID in the Node object.
     * @supplierCardinality 1..* 
     */
    Node ** d_nodes;

    /**
     * The number of Nodes in the nodes array. 
     */
    int d_numNodes;

    /**
     * The current size of the nodes array (must be as big or bigger than numNodes). 
     * Used for dynamic allocation of space for the array. 
     */
    int d_nodeArraySize;

    /**
     * @supplierCardinality 1..* 
     */
    Face ** d_faces;
    int d_numFaces;
    int d_faceArraySize;

    /**
     * Array of all the Elements in the mesh.
     * @supplierCardinality 1..* 
     */
    Element ** d_elements;
    int d_numElements;
    int d_elementArraySize;
    
    double minEdge;
};


inline Node* Mesh::getNode(int ID)
{ return d_nodes[ID-1]; }

inline Face* Mesh::getFace(int ID)
{return d_faces[ID-1];}

inline Element* Mesh::getElement(int ID)
{ return d_elements[ID-1];}

inline int Mesh::getNumNodes()
{ return d_numNodes; }

inline int Mesh::getNumFaces()
{ return d_numFaces; }

inline int Mesh::getNumElements()
{ return d_numElements; }

inline double Mesh::getMinEdge()
{ return minEdge; }

inline void Mesh::setMinEdge(double me)
{ minEdge = me ; }

#endif //MESH_H
