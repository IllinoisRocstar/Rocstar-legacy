/* Generated by Together */

#include "Element.hpp"
#include "HexElement.hpp"
#include "TetElement.hpp"
#include "TCoElement.hpp"
#include "QCoElement.hpp"
#include "Node.hpp"
#include "Face.hpp"
#include "Mesh.hpp"
#include <assert.h>
#include <math.h>

Mesh* Element::s_mesh = 0;


Element::Element( Type type ) :
d_eType( type ),
d_ID(-1),
d_nodes(0),
d_faces(0),
d_materialType( e_unset_material )
{}

Element::~Element(){

  if( d_nodes ){
    delete [] d_nodes;
  }
  if( d_faces ){
    delete [] d_faces;
  }
}

Element* Element::create( int id, Element::Type type ){

  Element *elem;

  switch( type ){
  case e_hex:
    elem = new HexElement();
    break;
  case e_tet:
    elem = new TetElement();
    break;
  case e_tri_cohesive:
    elem = new TCoElement();
    break;
  case e_quad_cohesive:
    elem = new QCoElement();
    break;
  default:
    cerr << "BUG: Illegal element type in construction " << type << endl;
  }
  elem->setID( id );
  return elem;
}

void Element::setFromNodes(Node ** thenodes){

  int numn = getNumNodes();
  int i;
  for( i = 0; i < numn; i++ ){
    d_nodes[i] = thenodes[i];
    d_nodes[i]->addElement( this );
  }
  setFromMyNodes();
}

istream& operator>>(istream& stream, Element& elem){

  // read material
  stream >> elem.d_materialType;

  // read nodes & set

  int numn = elem.getNumNodes();
  int i;
  for( i = 0; i < numn; i++ ){
    int node_id;
    stream >> node_id;
    Node *node = elem.s_mesh->getNode(node_id);
    elem.d_nodes[i] = node;
    node->addElement( &elem );
  }
  elem.setFromMyNodes();
  return stream;

}

ostream& operator<<(ostream& stream, Element& elem){

	stream << elem.d_ID << '\t' << elem.d_eType << '\t' << elem.d_materialType;
	
	// write nodes out to file.
	
	//OK, we have to special-case the cohesive elements due to
	//the strange way that they are supposed to be output.  So, 
	//the tet-cohesive element needs to have 1-2-3 as usual, but then "4" should be 
	//the node that matches up with node 3, instead of node 1.  Thus, since
	//the elements are stored 1-2-3 4-5-6, with 4 matched with 1, 5 matched
	//with 2, etc., we have to output 1-2-3-6-4-5.  Similarly, for the 
	//quad cohesive, we output 1-2-3-4-8-5-6-7.
	switch(elem.d_eType) {
	case 2:  //e_tri_cohesive
		stream << '\t' << elem.d_nodes[0]->getID();
		stream << '\t' << elem.d_nodes[1]->getID();
		stream << '\t' << elem.d_nodes[2]->getID();
		stream << '\t' << elem.d_nodes[5]->getID();
		stream << '\t' << elem.d_nodes[3]->getID();
		stream << '\t' << elem.d_nodes[4]->getID();
		stream << endl;
		break;
	case 3:  //e_quad_cohesive
		stream << '\t' << elem.d_nodes[0]->getID();
		stream << '\t' << elem.d_nodes[1]->getID();
		stream << '\t' << elem.d_nodes[2]->getID();
		stream << '\t' << elem.d_nodes[3]->getID();
		stream << '\t' << elem.d_nodes[7]->getID();
		stream << '\t' << elem.d_nodes[4]->getID();
		stream << '\t' << elem.d_nodes[5]->getID();
		stream << '\t' << elem.d_nodes[6]->getID();
		stream << endl;
		break;
	default:
		//put out in the order it's stored in the d_nodes array. 
		//default for normal tet and brick elements. 
		int numn = elem.getNumNodes();
		int i;
		for( i = 0; i < numn; i++ ){
		stream << '\t' << elem.d_nodes[i]->getID();
		}
		stream << endl;
	}
  	return stream;
}

void Element::replaceNode (Node *node, Node *new_node ) {

  int i;
  int numn = getNumNodes();
  for( i = 0; i< numn; i++ ){
    if( d_nodes[i] == node ){
      d_nodes[i] = new_node;
      node->removeElement( this );
      new_node->addElement( this );
    }
  }
  int numf = getNumFaces();
  for( i = 0; i < numf; i++ ){
    d_faces[i]->replaceNode( node, new_node );
  }
}

void Element::replaceFace (Face *face, Face *new_face){

  int i;
  int numf = getNumFaces();
  for( i = 0; i< numf; i++ ){
    if( d_faces[i] == face ){
      d_faces[i] = new_face;
    }
  }
}

//The following two methods should be overridden in derived classes.

void Element::replaceFaceNode (Node *node, Node *new_node, Face* face ) {
  assert( 0 );
}


double Element::getMinEdgeLength(){
  assert( 0 );
}

