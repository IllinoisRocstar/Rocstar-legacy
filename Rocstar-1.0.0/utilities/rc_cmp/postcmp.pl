#!/usr/bin/perl -w
##----------------------------------------------------------------------------
# This utility perl script will extract the metric values from
# the output file(s) generated using rc_cmp and will generate
# a colon delimited file that can be imported to Spreadsheet 
# software such as Micro$oft Excell.
#
# Description:
#
# The input to the script is the path to the root directory
# consisting of all the case comparissons. Each case is stored
# as a separte directory. Within each case directory the file
# output.dat consists of the raw output generated by rc_cmp
# and this is the file that will be parsed to extract the metric 
# values. Thus, the file output.dat must exist. For example, 
# consider the following hierarchy:
#
# Comparissons/
#   |
#   |------- Case_1/
#   |         |
#   |         |----> output.dat
#   |
#   |------- Case_2/
#   |         |
#   |         |----> output.dat
#   |
#  ---
# 
# Author : George Zagaris (gzagaris@illinois.edu)
# Date   : 1/13/2010
#
#-----------------------------------------------------------------------------

use strict;
use warnings;

### List of Perl Module used
use File::Find;
use File::Basename;

### Global array where the data for each case will be stored
my @globalarray;

##========================================================================
##                      P R O G R A M    M A I N
##========================================================================

### Parse the command line arguments. 
my $numArgs = $#ARGV + 1;
if( $numArgs != 1 ) {
  die( "Invalid number of command line arguments!\n" );
}

### Process the root directory
my $rootDirectory = shift;
print "Root Directory: ".$rootDirectory."\n";
directoryExists( $rootDirectory )or 
  die( "Root directory does not exist!\n" );

processData( $rootDirectory );

### Write spreadsheet
my($name,$path) = fileparse( $rootDirectory );
writeSpreadsheet( $path.$name."/Spreadsheet.xls" );

### Exit the program 
exit;

##========================================================================
##          S U B R O U T I N E   D E F I N I T I O N S 
##========================================================================

##========================================================================
# Description: Process the comparison data found in base-directory.
#
# Parameters:
#   dir -- the base directory 
#
# Postcondition: The global @data array is populated
##========================================================================
sub processData
{
  my ($baseDir) = @_;
  my @subdirs   = getSubdirs( $baseDir );
  print "Number of experiments: ".scalar(@subdirs)."\n";
  
  foreach( @subdirs ) {
   processCase( $_ ); 
  }

}

##========================================================================
# Description: Processes the case .
#
# Parameters:
#   case -- the case to process
#
# Postcondition: The global @data arr@y is populated
##========================================================================
sub processCase
{
  my ($case)       = @_;
  my ($name,$path) = fileparse( $case );
  print "Processing case: ".$name."...";

  ### Extract the data from the raw data file
  my( $mse, $rmse, $cc, $scc, $me ) = 
        extractData( $path.$name."/output.dat" );

  ### Push the data to the global array
  push( @globalarray, $name );
  push( @globalarray, $mse  );
  push( @globalarray, $rmse );
  push( @globalarray, $cc   );
  push( @globalarray, $scc  );
  push( @globalarray, $me   );

  print "[DONE]\n";
}

##========================================================================
# Description: Extracts the data from the specified file
#
# Parameters:
#   file -- the raw output file from which the data will be extracted
#
# Return:
#   mse  -- the mean-square error
#   rmse -- the root mean-square error
#   cc   -- the cross-correlation value
#   scc  -- the sample cross-correlation value
#   me   -- the modeling efficiency
##========================================================================
sub extractData
{
  my ($file) = @_;

  my @data   = ( );
 
  ### Parse the file
  fileExists( $file ) or
    die( "Cannot access file $file\n" );

  ### Load contents into memory
  open( MYFILE, $file ) or
    die( "Cannot open file $file\n" );
  my $contents = join( "", <MYFILE> );
  close( MYFILE );

  ### Setup the query strings to be used when appying regular expressions.
  my @qstring = ( "Mean Square Error:",
                  "Root Mean Square Error:",
                  "Cross-Correlation / Template Matching:",
                  "Sample Correlation Coefficient:",
                  "Modelling Efficiency:" );

  ### Apply regular expressions to the file contents
  foreach( @qstring )
  {
      my $query = $_;
      if( $contents =~ m/$query(.*)[-+]?[0-9]*\.?[0-9]*/ ) {
        push( @data, trim( $1 ) );
      }
      else {
        push( @data, 0.0 );
        print  "WARNING: Could not find $query!\n";
      }
  }

  ( scalar(@data) == scalar(@qstring) ) or 
    die( "Array mismatch!!!!\n" );

  return( @data );
}

##========================================================================
# Description: Removes leading & trailing whitespace.
# 
# Parameters
#   str -- the string from which the whitespace will be removed
#
# Return
#  ~str -- the modified string after the whitespace is removed.
#
##========================================================================
sub trim
{
  my $string = shift;
  $string =~ s/^\s+//;
  $string =~ s/\s+$//;
  return( $string );
}

##========================================================================
# Description: Writes the spreadsheet.
# Postcondition: A spreadsheet datafile is written
##========================================================================
sub writeSpreadsheet
{
  print "Writting spreadsheet...";
  
  ### Open a file handle
  my ($file) = @_;
  open( OFH, ">$file" ) or
    die( "Cannot write file $file!\n" );
  
  ### Print the header
  print OFH "Experiment:";
  print OFH "Meah Square Error:";
  print OFH "Root Mean Square Error:";
  print OFH "Cross Correlation / Template Matching:";
  print OFH "Sample Correlation Coefficient:";
  print OFH "Modelling Efficiency:\n";

  my $N = scalar( @globalarray )/6;
  for( my $i=0; $i < $N; ++$i )
  {

    for my $j (0..5) {
      print OFH $globalarray[ $i*6+$j ].":";
    } # End for all j
    print OFH "\n";

  } # End for all i


  ### Close a file handle
  close( OFH );

  print "[DONE]\n";
}

##========================================================================
# Description: Finds all the sub-directories within the base directory.
#
# Parameters:
#   dir -- the base directory 
#
# Return values:
#   subdirs -- List of the sub-directories within dir
##========================================================================
sub getSubdirs
{
  my ($baseDir) = @_;
  my @subdirs;

  ### Find the all the subdirectories. 
  File::Find::find
  (
    sub { 
      if( (-d $_) and ($baseDir ne $File::Find::name) ) { 
        push( @subdirs, $File::Find::name ); 
      } 
      return; 
    },
    $baseDir
  );

  ### Return pointer to the subdirs array
  return( @subdirs );
}

##========================================================================
# Description: Checks if a directory exists
# 
# Parameters:
#   dir -- the directory to check
#
# Return values:
#   val -- 1(true) if the directory exists or 0(false) if the directory
#   does not exist.
##========================================================================
sub directoryExists
{
  my ($dirToCheck) = @_;
  if( -d $dirToCheck ) {
    return( 1 ); 
  }
  else {
    return( 0 );
  }
}

##========================================================================
# Description: Checks if a directory exists
# 
# Parameters:
#   file -- the file to check
#
# Return values:
#   val -- 1(true) if the file exists or 0(false) if the file
#   does not exist.
##========================================================================
sub fileExists
{

  my ($fileToCheck) = @_;
  if( -e $fileToCheck ) {
    return( 1 );
  }
  else {
    return( 0 );
  }

}
